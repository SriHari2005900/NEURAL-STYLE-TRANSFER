"""
Neural Style Transfer (Gatys et al.)
Python script / notebook code (PyTorch) - run in Google Colab or local machine.

Usage examples:
1) In terminal:
   python neural_style_transfer.py --content_path content.jpg --style_path style.jpg --output_path output.jpg

2) In Colab: upload content.jpg and style.jpg and run the script cell (or call the functions below).

Dependencies:
- torch
- torchvision
- pillow
- matplotlib

If using Colab, run: `!pip install torch torchvision pillow matplotlib` (Colab usually has torch preinstalled).

This implementation follows the classical optimization-based approach:
- Use pretrained VGG19 to extract features
- Define ContentLoss and StyleLoss (Gram matrix)
- Optimize an input image (initialized from content image) to match content & style targets

Notes:
- Adjust content_weight and style_weight to taste.
- For faster results consider using feature transformation methods (AdaIN) or pretrained feed-forward models.

Author: Generated by ChatGPT
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import transforms, models
from PIL import Image
import copy
import argparse
import os

# --------------------------- Utilities ---------------------------

def load_image(image_path, device, imsize=512):
    image = Image.open(image_path).convert('RGB')
    loader = transforms.Compose([
        transforms.Resize(imsize),  # scale imported image
        transforms.CenterCrop(imsize),
        transforms.ToTensor()])
    image = loader(image).unsqueeze(0)  # add batch dimension
    return image.to(device, torch.float)


def save_image(tensor, path):
    unloader = transforms.ToPILImage()
    image = tensor.cpu().clone().squeeze(0)
    image = torch.clamp(image, 0, 1)
    image = unloader(image)
    image.save(path)


def imshow(tensor, title=None):
    import matplotlib.pyplot as plt
    unloader = transforms.ToPILImage()
    image = tensor.cpu().clone().squeeze(0)
    image = torch.clamp(image, 0, 1)
    plt.imshow(image)
    if title is not None:
        plt.title(title)
    plt.axis('off')
    plt.show()

# --------------------------- Gram Matrix ---------------------------

class GramMatrix(nn.Module):
    def forward(self, input):
        b, ch, h, w = input.size()
        features = input.view(b * ch, h * w)
        G = torch.mm(features, features.t())
        # Normalize by number of elements
        return G.div(b * ch * h * w)

# --------------------------- Loss Modules ---------------------------

class ContentLoss(nn.Module):
    def __init__(self, target, weight=1.0):
        super(ContentLoss, self).__init__()
        # we "detach" the target content from the tree used
        # to dynamically compute the gradient: this is a stated value,
        # not a variable. Otherwise the forward method would change it.
        self.target = target.detach()
        self.weight = weight
        self.loss = 0

    def forward(self, input):
        self.loss = nn.functional.mse_loss(input * self.weight, self.target * self.weight)
        return input

class StyleLoss(nn.Module):
    def __init__(self, target_feature, weight=1.0):
        super(StyleLoss, self).__init__()
        self.target = target_feature.detach()
        self.gram = GramMatrix()
        self.weight = weight
        self.loss = 0

    def forward(self, input):
        G = self.gram(input)
        self.loss = nn.functional.mse_loss(G * self.weight, self.target * self.weight)
        return input

# --------------------------- Model builder ---------------------------

# VGG networks are trained on images with each channel normalized
# by mean=[0.485, 0.456, 0.406] and std=[0.229, 0.224, 0.225].
# We will create modules to normalize input accordingly.

class Normalization(nn.Module):
    def __init__(self, mean, std):
        super(Normalization, self).__init__()
        # .view the mean and std to make them [C x 1 x 1] so they can
        # directly work with image Tensor of shape [B x C x H x W].
        self.mean = torch.tensor(mean).view(-1, 1, 1)
        self.std = torch.tensor(std).view(-1, 1, 1)

    def forward(self, img):
        # normalize img
        return (img - self.mean.to(img.device)) / self.std.to(img.device)


def get_style_model_and_losses(cnn, normalization_mean, normalization_std,
                               style_img, content_img,
                               content_layers=['conv_4'],
                               style_layers=['conv_1', 'conv_2', 'conv_3', 'conv_4', 'conv_5'],
                               device='cpu',
                               style_weight=1e6, content_weight=1):
    # Make a copy of the cnn so we don't modify the original
    cnn = copy.deepcopy(cnn)

    normalization = Normalization(normalization_mean, normalization_std).to(device)

    # Containers for losses
    content_losses = []
    style_losses = []

    # Sequential model to build
    model = nn.Sequential(normalization)

    i = 0  # increment every time we see a conv
    for layer in cnn.children():
        if isinstance(layer, nn.Conv2d):
            i += 1
            name = f'conv_{i}'
        elif isinstance(layer, nn.ReLU):
            name = f'relu_{i}'
            # The in-place version doesn't play nicely with the loss modules
            layer = nn.ReLU(inplace=False)
        elif isinstance(layer, nn.MaxPool2d):
            name = f'pool_{i}'
        elif isinstance(layer, nn.BatchNorm2d):
            name = f'bn_{i}'
        else:
            name = f'unknown_{i}'

        model.add_module(name, layer)

        if name in content_layers:
            # add content loss
            target = model(content_img).detach()
            content_loss = ContentLoss(target, weight=content_weight)
            model.add_module("content_loss_{}".format(i), content_loss)
            content_losses.append(content_loss)

        if name in style_layers:
            # add style loss
            target_feature = model(style_img).detach()
            gram = GramMatrix()
            target_gram = gram(target_feature)
            style_loss = StyleLoss(target_gram, weight=style_weight)
            model.add_module("style_loss_{}".format(i), style_loss)
            style_losses.append(style_loss)

    # Now we trim off the layers after the last content and style losses
    for i in range(len(model) - 1, -1, -1):
        if isinstance(model[i], ContentLoss) or isinstance(model[i], StyleLoss):
            break
    model = model[:(i + 1)]

    return model, style_losses, content_losses

# --------------------------- Run style transfer ---------------------------

def run_style_transfer(cnn, normalization_mean, normalization_std,
                       content_img, style_img, input_img, device,
                       num_steps=300, style_weight=1e6, content_weight=1):
    print('Building the style transfer model..')
    model, style_losses, content_losses = get_style_model_and_losses(cnn, normalization_mean, normalization_std,
                                                                     style_img, content_img,
                                                                     device=device,
                                                                     style_weight=style_weight,
                                                                     content_weight=content_weight)

    # We want to optimize the input image. Requires grad.
    input_img.requires_grad_(True)
    model.requires_grad_(False)

    optimizer = optim.LBFGS([input_img])

    print('Optimizing..')
    run = [0]
    while run[0] <= num_steps:

        def closure():
            # correct the values of updated input image
            with torch.no_grad():
                input_img.clamp_(0, 1)

            optimizer.zero_grad()
            model(input_img)
            style_score = 0
            content_score = 0

            for sl in style_losses:
                style_score += sl.loss
            for cl in content_losses:
                content_score += cl.loss

            loss = style_score + content_score
            loss.backward()

            if run[0] % 50 == 0:
                print(f"run {run[0]}: style_loss : {style_score.item():4f} content_loss: {content_score.item():4f}")

            run[0] += 1
            return loss

        optimizer.step(closure)

    # a last correction
    with torch.no_grad():
        input_img.clamp_(0, 1)

    return input_img

# --------------------------- Main / CLI ---------------------------

def main():
    parser = argparse.ArgumentParser(description='Neural Style Transfer - Gatys')
    parser.add_argument('--content_path', type=str, required=True, help='Path to content image')
    parser.add_argument('--style_path', type=str, required=True, help='Path to style image')
    parser.add_argument('--output_path', type=str, default='output.jpg', help='Where to save the output')
    parser.add_argument('--imsize', type=int, default=512, help='Image size (max dimension)')
    parser.add_argument('--steps', type=int, default=300, help='Number of optimization steps')
    parser.add_argument('--style_weight', type=float, default=1e6, help='Style weight')
    parser.add_argument('--content_weight', type=float, default=1, help='Content weight')
    args = parser.parse_args()

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print('Using device:', device)

    # Load images
    content_img = load_image(args.content_path, device, imsize=args.imsize)
    style_img = load_image(args.style_path, device, imsize=args.imsize)

    assert content_img.size() == style_img.size(), "Content and style images must be the same size"

    # Input image: start from content image (or white noise)
    input_img = content_img.clone()

    # Load pre-trained VGG19
    cnn = models.vgg19(pretrained=True).features.to(device).eval()

    # Normalization mean & std for ImageNet
    cnn_normalization_mean = [0.485, 0.456, 0.406]
    cnn_normalization_std = [0.229, 0.224, 0.225]

    output = run_style_transfer(cnn, cnn_normalization_mean, cnn_normalization_std,
                                content_img, style_img, input_img, device,
                                num_steps=args.steps,
                                style_weight=args.style_weight,
                                content_weight=args.content_weight)

    # Save
    os.makedirs(os.path.dirname(args.output_path) or '.', exist_ok=True)
    save_image(output, args.output_path)
    print('Saved output to', args.output_path)


if __name__ == '__main__':
    main()
